<!DOCTYPE html>
<html>
	<head>
		<script src ="jquery-1.9.1.min.js"></script>
		<script src ="three.js"></script>
		<style type="text/css">
         body {
               overflow: hidden;
           }
       </style>
	</head>
	<body>
		<div id="container"></div>
		<script type="text/javascript">
		
			var WIDTH = window.innerWidth,
				HEIGHT = window.innerHeight;
			var Camera;
			var Scene;
			var Renderer;
			var mouse = { 
				down: false,
				prevY: 0,
				prevX: 0
						}
			var keysPressed = [];
			var camobject = null;
			var MOUSESENS = 0.005;
			var Ruins = [];
			var RoboHand = null;
				
			Init();
			Animate();
			

			function Init()
			{
				var VIEW_ANGLE = 50, //vertical FOV. Horizontal is approx 80, I guess
					ASPECT = WIDTH / HEIGHT,
					NEAR = 0.1,
					FAR = 100000;
							
				var $container = $('#container');
				
			//Create cam, renderer and scene
				Renderer = new THREE.WebGLRenderer({antialias:true});
				Camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR );
				Scene = new THREE.Scene();
				camobject = new THREE.Object3D();
				camobject.add(Camera); //making cam a child of camobject
				camobject.position.z = 5;
				camobject.position.y = 1.0;
				Scene.add(camobject);
				Renderer.setSize(WIDTH, HEIGHT); //Start renderer
				
			//Attach the renderer to DOM element
				$container.append(Renderer.domElement);
				
				t_Floor = THREE.ImageUtils.loadTexture("SquaredConcrete1.jpg");
				
				//Texture filtering:
				t_Floor.anisotropy = Renderer.getMaxAnisotropy();
				
				t_Floor.wrapS = THREE.RepeatWrapping;
				t_Floor.wrapT = THREE.RepeatWrapping;
				t_Floor.repeat.set(32,32);
				
			// create a new mesh with cube geometry -
				var cube = new THREE.Mesh(
				new THREE.CubeGeometry(50,0.2,50, 1, 1, 1), new THREE.MeshBasicMaterial(
				{   
					map: t_Floor,
					transparent: true
				}));
				
			
				
				Scene.add(cube);
				
			//Mesh loading functionality
				var loader = new THREE.JSONLoader();
				function handler(geometry, materials)
				{
					Ruins.push( new THREE.Mesh(geometry, new THREE.MeshBasicMaterial(
					{map: THREE.ImageUtils.loadTexture("rock.jpg"), transparent: true}
					)));
					checkIsAllLoaded();
					
				}
				function checkIsAllLoaded()
				{
					if( Ruins.length == 5 )
					{
						$.each(Ruins, function(i,mesh)
						{
							mesh.rotation.x = Math.PI/2; ///rotate by 90 deg
							Scene.add(mesh);
						});
						Ruins[0].position.z = 13;
						Ruins[1].position.x = -8;
						Ruins[2].position.z = 8;
						Ruins[2].position.x = -5;
						Ruins[4].position.z = 2;
						Ruins[3].position.x = 7;
					}
				}
				//upon finish of the loading process each model will recall a handler func
				loader.load("meshes/ruins30.js", handler);
				loader.load("meshes/ruins31.js", handler);
				loader.load("meshes/ruins33.js", handler);
				loader.load("meshes/ruins34.js", handler);
				loader.load("meshes/ruins35.js", handler);
				
				
				//Now adding the hand!
				RoboHand = new Hand(Scene, 0,0,2);
				
				Renderer.render(Scene, Camera);
				
		///Handle mouse input
				document.onmousedown = function(ev)
				{
					mouse.down = true;
					mouse.prevY = ev.pageY;
					mouse.prevX = ev.pageX;
				}
				document.onmouseup = function(ev)
				{
					mouse.down = false;
				}
				document.onmousemove = function(ev)
				{
					if( mouse.down )
					{
						var rot = (ev.pageY - mouse.prevY) * MOUSESENS;
						var rotY = (ev.pageX - mouse.prevX) * MOUSESENS;
						camobject.rotation.y -= rotY;
					//Make sure we dont "overlook" down or up:
						if( ( (Camera.rotation.x <= 1.5) || (rot > 0.0) ) && ( (Camera.rotation.x >= -1.5) || (rot < 0.0)))
						{
							Camera.rotation.x -= rot;
						}
						
						mouse.prevY = ev.pageY;
						mouse.prevX = ev.pageX;
					}
				}
		///Handle keyboard input
				document.onkeydown = function(event){
					keysPressed[event.keyCode] = true;
				}
				document.onkeyup = function(event){
					keysPressed[event.keyCode] = false;
				}
				
				
			}
			
			function Animate()
			{
				Renderer.setClearColorHex(0x000000, 1.0);
				Renderer.clear(true);
				Renderer.render(Scene, Camera);
				if( keysPressed["W".charCodeAt(0)] == true ){
					var dir = new THREE.Vector3(0,0,-1);
					var dirW = dir.applyMatrix4(camobject.matrixRotationWorld);
					camobject.translate(0.1, dirW);
				}
				if( keysPressed["S".charCodeAt(0)] == true ){
					var dir = new THREE.Vector3(0,0,-1);
					var dirW = dir.applyMatrix4(camobject.matrixRotationWorld);
					camobject.translate(-0.1, dirW);
				}
				if( keysPressed["A".charCodeAt(0)] == true ){
					var dir = new THREE.Vector3(-1,0,0);
					var dirW = dir.applyMatrix4(camobject.matrixRotationWorld);
					camobject.translate(0.1, dirW);
				}
				if( keysPressed["D".charCodeAt(0)] == true ){
					var dir = new THREE.Vector3(1,0,0);
					var dirW = dir.applyMatrix4(camobject.matrixRotationWorld);
					camobject.translate(0.1, dirW);
				}
				
				if(RoboHand != null){
					RoboHand.Wave(Date.now());
				}
				requestAnimationFrame(Animate); //called by browser-supported timer loop. 
			}
			
		///Making a class for a hand. Will simplify the code and overall usage
			function Hand(Scene, x, y, z)
			{
				//Starting with shoulder as a parent for alll other arm parts. Adding it as a child to a scene.
				this.Shoulder = new THREE.Mesh(new THREE.SphereGeometry(0.2,30,30), new THREE.MeshBasicMaterial( {color: 0xff0000} ));
				Scene.add(this.Shoulder);
				this.Shoulder.position.x = x;
				this.Shoulder.position.y = y + 1.3; //Height so that whole arm can be upper then floor
				this.Shoulder.position.z = z;
				this.Shoulder.rotation.x = 0;
				this.Shoulder.rotation.y = 0;
				this.Shoulder.rotation.z = 0;
				///WRITE HERE ROTATION MANUALY
				
				this.UpperArm = new THREE.Mesh(new THREE.CubeGeometry(0.5,0.15,0.15, 1, 1, 1), new THREE.MeshBasicMaterial( {color: 0x00ff00} ));
				this.UpperArm.position.x = x + 0.4;
				this.UpperArm.position.y = y;
				this.UpperArm.position.z = z - 2.01;
				this.Shoulder.add(this.UpperArm);
				
				this.Elbow = new THREE.Mesh(new THREE.SphereGeometry(0.15,30,30), new THREE.MeshBasicMaterial( {color: 0xff00ff} ));
				this.Elbow.position.x = x + 0.3;
				this.Elbow.position.y = y;
				this.Elbow.position.z = z - 2.01;
				this.UpperArm.add(this.Elbow);
				
				this.LowerArm = new THREE.Mesh(new THREE.CubeGeometry(0.5,0.15,0.15, 1, 1, 1), new THREE.MeshBasicMaterial( {color: 0x0000ff} ));
				this.LowerArm.position.x = x + 0.3;
				this.LowerArm.position.y = y;
				this.LowerArm.position.z = z - 2.01;
				this.Elbow.add(this.LowerArm);
				
				this.Wrist = new THREE.Mesh(new THREE.CubeGeometry(0.3,0.32,0.18, 1, 1, 1), new THREE.MeshBasicMaterial( {color: 0x00ffff} ));
				this.Wrist.position.x = x + 0.39;
				this.Wrist.position.y = y;
				this.Wrist.position.z = z - 2.01;
				this.LowerArm.add(this.Wrist);
				
				this.Fingers = [new THREE.Mesh(new THREE.CubeGeometry(0.3,0.05,0.05, 1, 1, 1), new THREE.MeshBasicMaterial( {color: 0xffff0f} )),
							   new THREE.Mesh(new THREE.CubeGeometry(0.3,0.05,0.05, 1, 1, 1), new THREE.MeshBasicMaterial( {color: 0xffff0f} )),
							   new THREE.Mesh(new THREE.CubeGeometry(0.3,0.05,0.05, 1, 1, 1), new THREE.MeshBasicMaterial( {color: 0xffff0f} )),
							   new THREE.Mesh(new THREE.CubeGeometry(0.4,0.05,0.05, 1, 1, 1), new THREE.MeshBasicMaterial( {color: 0xffff0f} ))];
				for( i = 0; i < this.Fingers.length; i++){
					this.Fingers[i].position.x = x + 0.28;
					this.Fingers[i].position.y = y +0.11 - (0.1 * i);
					this.Fingers[i].position.z = z - 2.01;
					this.Wrist.add(this.Fingers[i]);
				}
				//Thumb:
				this.Fingers[3].rotation.z -= 0.7;
				this.Fingers[3].position.x -= 0.2;
				
			///Method of waving:
				this.Wave = function(Delta)
				{
					//Let's start with some simple upperhand movement
					this.Shoulder.rotation.z = Math.PI/2 + (Math.cos( Delta * 0.001 ))* 1.7;
					//Next, let's work on elbow rotation
					this.Elbow.rotation.z = Math.sin(Delta * 0.0015 );
					//At last, let's make the wrist move
					this.Wrist.rotation.y = Math.cos(Delta * 0.0017 );
				}
			}
			
			
		</script>
	</body>
</html>